package modes

import (
	"reflect"
	"testing"
)

func TestPKCS7_Pad(t *testing.T) {
	type args struct {
		data      []byte
		blockSize int
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "8_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x02, 0x02},
		},
		{
			name: "8_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x03, 0x03, 0x03},
		},
		{
			name: "16_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a},
		},
		{
			name: "16_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pk := &PKCS7{}
			if got := pk.Pad(tt.args.data, tt.args.blockSize); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Pad() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestPKCS7_UnPad(t *testing.T) {
	type args struct {
		data      []byte
		blockSize int
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "8_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x02, 0x02}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b},
		},
		{
			name: "8_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x03, 0x03, 0x03}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90},
		},
		{
			name: "16_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b},
		},
		{
			name: "16_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			pk := &PKCS7{}
			if got := pk.UnPad(tt.args.data, tt.args.blockSize); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UnPad() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestISO_Pad(t *testing.T) {
	type args struct {
		data      []byte
		blockSize int
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "8_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x80, 0x0},
		},
		{
			name: "8_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x80, 0x0, 0x0},
		},
		{
			name: "16_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			name: "16_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			iso := &ISO{}
			if got := iso.Pad(tt.args.data, tt.args.blockSize); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("Pad() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestISO_UnPad(t *testing.T) {
	type args struct {
		data      []byte
		blockSize int
	}
	tests := []struct {
		name string
		args args
		want []byte
	}{
		{
			name: "8_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x80, 0x0}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b},
		},
		{
			name: "8_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x80, 0x0, 0x0}, blockSize: 8},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90},
		},
		{
			name: "16_byte_1",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x9b},
		},
		{
			name: "16_byte_2",
			args: args{data: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, blockSize: 16},
			want: []byte{0x45, 0x67, 0x7a, 0x89, 0x90, 0x87, 0x12, 0xf6, 0x8e},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			iso := &ISO{}
			if got := iso.UnPad(tt.args.data, tt.args.blockSize); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("UnPad() = %v, want %v", got, tt.want)
			}
		})
	}
}
