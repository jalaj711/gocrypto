package des

import (
	"fmt"
	"testing"
)

func TestGetReducedKey(t *testing.T) {
	test := [8]byte{0b00010011, 0b00110100, 0b01010111, 0b01111001, 0b10011011, 0b10111100, 0b11011111, 0b11110001}
	expected := [7]byte{0b11110000, 0b11001100, 0b10101010, 0b11110101, 0b01010110, 0b01100111, 0b10001111}
	key := getReducedKey(test)
	// t.Logf(`Testcase: %b, result: %d`, test, key)
	if key != expected {
		t.Fatalf(`Testcase: %b, result: %b`, test, key)
	}
}

func TestLeftRotateKeySingleShift(t *testing.T) {
	test := [7]byte{0b11110000, 0b11001100, 0b10101010, 0b11110101, 0b01010110, 0b01100111, 0b10001111}
	key := leftRotateKey(test, 1)
	expected := [7]byte{0b11100001, 0b10011001, 0b01010101, 0b11111010, 0b10101100, 0b11001111, 0b00011110}
	// t.Logf(`Testcase: %b, result: %d`, test, key)
	if key != expected {
		t.Fatalf(`Testcase: %b result: %b\n expected: %b`, test, key, expected)
	}
}

func TestLeftRotateKeyDoubleShift(t *testing.T) {
	test := [7]byte{0b11000011, 0b00110010, 0b10101011, 0b11110101, 0b01011001, 0b10011110, 0b00111101}
	key := leftRotateKey(test, 2)
	expected := [7]byte{0b00001100, 0b11001010, 0b10101111, 0b11110101, 0b01100110, 0b01111000, 0b11110101}
	// t.Logf(`Testcase: %b, result: %d`, test, key)
	if key != expected {
		t.Fatalf(`Testcase: %b result: %b\n expected: %b`, test, key, expected)
	}
}

func TestRotatedRoundKeys(t *testing.T) {
	test := [7]byte{0b11110000, 0b11001100, 0b10101010, 0b11110101, 0b01010110, 0b01100111, 0b10001111}
	key := getRotatedRoundKeys(test)
	expected := [16][7]byte{
		{0b11100001, 0b10011001, 0b01010101, 0b11111010, 0b10101100, 0b11001111, 0b00011110},
		{0b11000011, 0b00110010, 0b10101011, 0b11110101, 0b01011001, 0b10011110, 0b00111101},
		{0b00001100, 0b11001010, 0b10101111, 0b11110101, 0b01100110, 0b01111000, 0b11110101},
		{0b00110011, 0b00101010, 0b10111111, 0b11000101, 0b10011001, 0b11100011, 0b11010101},
		{0b11001100, 0b10101010, 0b11111111, 0b00000110, 0b01100111, 0b10001111, 0b01010101},
		{0b00110010, 0b10101011, 0b11111100, 0b00111001, 0b10011110, 0b00111101, 0b01010101},
		{0b11001010, 0b10101111, 0b11110000, 0b11000110, 0b01111000, 0b11110101, 0b01010110},
		{0b00101010, 0b10111111, 0b11000011, 0b00111001, 0b11100011, 0b11010101, 0b01011001},
		{0b01010101, 0b01111111, 0b10000110, 0b01100011, 0b11000111, 0b10101010, 0b10110011},
		{0b01010101, 0b11111110, 0b00011001, 0b10011111, 0b00011110, 0b10101010, 0b11001100},
		{0b01010111, 0b11111000, 0b01100110, 0b01011100, 0b01111010, 0b10101011, 0b00110011},
		{0b01011111, 0b11100001, 0b10011001, 0b01010001, 0b11101010, 0b10101100, 0b11001111},
		{0b01111111, 0b10000110, 0b01100101, 0b01010111, 0b10101010, 0b10110011, 0b00111100},
		{0b11111110, 0b00011001, 0b10010101, 0b01011110, 0b10101010, 0b11001100, 0b11110001},
		{0b11111000, 0b01100110, 0b01010101, 0b01111010, 0b10101011, 0b00110011, 0b11000111},
		{0b11110000, 0b11001100, 0b10101010, 0b11110101, 0b01010110, 0b01100111, 0b10001111},
	}
	// t.Logf(`Testcase: %b, result: %d`, test, key)
	if key != expected {
		t.Fatalf(`Testcase: %b result: %b\n expected: %b`, test, key, expected)
	}
}

func TestPermutedRoundKeys(t *testing.T) {
	test := [16][7]byte{
		{0b11100001, 0b10011001, 0b01010101, 0b11111010, 0b10101100, 0b11001111, 0b00011110},
		{0b11000011, 0b00110010, 0b10101011, 0b11110101, 0b01011001, 0b10011110, 0b00111101},
		{0b00001100, 0b11001010, 0b10101111, 0b11110101, 0b01100110, 0b01111000, 0b11110101},
		{0b00110011, 0b00101010, 0b10111111, 0b11000101, 0b10011001, 0b11100011, 0b11010101},
		{0b11001100, 0b10101010, 0b11111111, 0b00000110, 0b01100111, 0b10001111, 0b01010101},
		{0b00110010, 0b10101011, 0b11111100, 0b00111001, 0b10011110, 0b00111101, 0b01010101},
		{0b11001010, 0b10101111, 0b11110000, 0b11000110, 0b01111000, 0b11110101, 0b01010110},
		{0b00101010, 0b10111111, 0b11000011, 0b00111001, 0b11100011, 0b11010101, 0b01011001},
		{0b01010101, 0b01111111, 0b10000110, 0b01100011, 0b11000111, 0b10101010, 0b10110011},
		{0b01010101, 0b11111110, 0b00011001, 0b10011111, 0b00011110, 0b10101010, 0b11001100},
		{0b01010111, 0b11111000, 0b01100110, 0b01011100, 0b01111010, 0b10101011, 0b00110011},
		{0b01011111, 0b11100001, 0b10011001, 0b01010001, 0b11101010, 0b10101100, 0b11001111},
		{0b01111111, 0b10000110, 0b01100101, 0b01010111, 0b10101010, 0b10110011, 0b00111100},
		{0b11111110, 0b00011001, 0b10010101, 0b01011110, 0b10101010, 0b11001100, 0b11110001},
		{0b11111000, 0b01100110, 0b01010101, 0b01111010, 0b10101011, 0b00110011, 0b11000111},
		{0b11110000, 0b11001100, 0b10101010, 0b11110101, 0b01010110, 0b01100111, 0b10001111},
	}
	keys := getPermutedRoundKeys(test)
	expected := [16][6]byte{
		{0b00011011, 0b00000010, 0b11101111, 0b11111100, 0b01110000, 0b01110010},
		{0b01111001, 0b10101110, 0b11011001, 0b11011011, 0b11001001, 0b11100101},
		{0b01010101, 0b11111100, 0b10001010, 0b01000010, 0b11001111, 0b10011001},
		{0b01110010, 0b10101101, 0b11010110, 0b11011011, 0b00110101, 0b00011101},
		{0b01111100, 0b11101100, 0b00000111, 0b11101011, 0b01010011, 0b10101000},
		{0b01100011, 0b10100101, 0b00111110, 0b01010000, 0b01111011, 0b00101111},
		{0b11101100, 0b10000100, 0b10110111, 0b11110110, 0b00011000, 0b10111100},
		{0b11110111, 0b10001010, 0b00111010, 0b11000001, 0b00111011, 0b11111011},
		{0b11100000, 0b11011011, 0b11101011, 0b11101101, 0b11100111, 0b10000001},
		{0b10110001, 0b11110011, 0b01000111, 0b10111010, 0b01000110, 0b01001111},
		{0b00100001, 0b01011111, 0b11010011, 0b11011110, 0b11010011, 0b10000110},
		{0b01110101, 0b01110001, 0b11110101, 0b10010100, 0b01100111, 0b11101001},
		{0b10010111, 0b11000101, 0b11010001, 0b11111010, 0b10111010, 0b01000001},
		{0b01011111, 0b01000011, 0b10110111, 0b11110010, 0b11100111, 0b00111010},
		{0b10111111, 0b10010001, 0b10001101, 0b00111101, 0b00111111, 0b00001010},
		{0b11001011, 0b00111101, 0b10001011, 0b00001110, 0b00010111, 0b11110101},
	}
	// t.Logf(`Testcase: %b, result: %d`, test, key)
	if keys != expected {
		fmt.Println("Key No.  Byte No.      Output      Expected")
		fmt.Println("------   --------     --------     --------")
		for i := 0; i < 16; i++ {
			for j := 0; j < 6; j++ {
				fmt.Printf("%d          %d            %b      %b\n", i, j, keys[i][j], expected[i][j])
			}
		}
		t.Fatal(`Testcase failed`)
	}
}

func TestGenerateRoundKeys(t *testing.T) {
	test := [8]byte{0b00010011, 0b00110100, 0b01010111, 0b01111001, 0b10011011, 0b10111100, 0b11011111, 0b11110001}
	keys := getRoundKeys(test)
	expected := [16][6]byte{
		{0b00011011, 0b00000010, 0b11101111, 0b11111100, 0b01110000, 0b01110010},
		{0b01111001, 0b10101110, 0b11011001, 0b11011011, 0b11001001, 0b11100101},
		{0b01010101, 0b11111100, 0b10001010, 0b01000010, 0b11001111, 0b10011001},
		{0b01110010, 0b10101101, 0b11010110, 0b11011011, 0b00110101, 0b00011101},
		{0b01111100, 0b11101100, 0b00000111, 0b11101011, 0b01010011, 0b10101000},
		{0b01100011, 0b10100101, 0b00111110, 0b01010000, 0b01111011, 0b00101111},
		{0b11101100, 0b10000100, 0b10110111, 0b11110110, 0b00011000, 0b10111100},
		{0b11110111, 0b10001010, 0b00111010, 0b11000001, 0b00111011, 0b11111011},
		{0b11100000, 0b11011011, 0b11101011, 0b11101101, 0b11100111, 0b10000001},
		{0b10110001, 0b11110011, 0b01000111, 0b10111010, 0b01000110, 0b01001111},
		{0b00100001, 0b01011111, 0b11010011, 0b11011110, 0b11010011, 0b10000110},
		{0b01110101, 0b01110001, 0b11110101, 0b10010100, 0b01100111, 0b11101001},
		{0b10010111, 0b11000101, 0b11010001, 0b11111010, 0b10111010, 0b01000001},
		{0b01011111, 0b01000011, 0b10110111, 0b11110010, 0b11100111, 0b00111010},
		{0b10111111, 0b10010001, 0b10001101, 0b00111101, 0b00111111, 0b00001010},
		{0b11001011, 0b00111101, 0b10001011, 0b00001110, 0b00010111, 0b11110101},
	}
	// t.Logf(`Testcase: %b, result: %d`, test, key)
	if keys != expected {
		fmt.Println("Key No.  Byte No.      Output      Expected")
		fmt.Println("------   --------     --------     --------")
		for i := 0; i < 16; i++ {
			for j := 0; j < 6; j++ {
				fmt.Printf("%d          %d            %b      %b\n", i, j, keys[i][j], expected[i][j])
			}
		}
		t.Fatal(`Testcase failed`)
	}
}
